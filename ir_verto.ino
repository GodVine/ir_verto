#define IN_PIN 2        // входной пин


uint32_t us[4],com[2];// us масив с зашифрованным сигналом. 0 и 1 значение временные в которых записываются комманды в процессе получения
//us[2и3] записываются во время паузы между командами иначе команды будут прииходить частично измененные так как частота сигнала меньше частоты процессора
int tim_pause = 5000;// минимальная задержка между командами если пауза дольше этого значения счетчики обнуляются и ждем новой команды

uint32_t prevUs;//переменная для хранения времени предыдущего срабатывания
int count = 0;//счетчик сигналов
bool  first, prevS, flag = 0;
byte  bit1, bit2 ;
void setup() {
  Serial.begin(115200);
  delay(100);

  pinMode(IN_PIN, INPUT_PULLUP); 

  attachInterrupt(0, preriv, CHANGE);//инициалилируем прерывание на изменение состояние пина 2
}

void loop(){
  if ( (us[2]!=com[0])||(us[3]!=com[1])){// для того чтоб в мониторе порта не выводились повторные значения завел еще 2 переменных для контроля изменений
   com[0]=us[2];
   com[1]=us[3];
   for (int j=31; j>=0; j--) {//выводим их со страршего бита
    Serial.print(bitRead(us[2], j));//если старшие биты равны нулю то при обычном выводе они не покажутся для этого делаем цикл с условием если бит раве1 то выводит 1 если нулю
//  Serial.print(";"); //выводим между значениями ; для того чтоб при открытии екселем разделять значения в разные колонки.
    
   
   }
   //Serial.print(us[2], BIN);// способ не работает пропускает старшие нули
   Serial.print(" ");//промежуток между переменными легче ориентироваться.
   for (int i=31; i>=0; i--) { //здесь все тоже самое
     Serial.print(bitRead(us[3], i));
   //Serial.print(";");
   //Serial.println(us[3], BIN);
  
  }
   Serial.println();
}
}

void preriv() {
  // читаем время
  uint32_t now = micros();
 
  if ((now - prevUs)>tim_pause) {//если время с последнего срабатывания превышает tim_pause обнуляем счетчики
      us[2]=us[0];//записываем временные переменные в постоянное место переменная полностью изменилась
      us[3]=us[1];
      flag=0;
      count=0;
      bit1=0;
      bit2=0;
  }
    if (!flag) {      // триггер (первое срабатывание)
      flag = 1;       // запомнили
      prevUs = now;   // время первого
    } else {                      // измеряем следующие
       if (count>0) { //пропускаем второе срабатывание так как это был стартовый сигнал
          if (count<33){//так как максимальная (стабильно работающая)переменная uint32_t содержит 32 бита а у нас их 64 делим данные на 2 переменных
            bitWrite(us[0] ,(31-bit1), ((now - prevUs)>800)) ;//если время предыдущего срабатывания минус текущее время больше 800 мс записываем 1 иначе 0 в соответствующий бит
            bit1++;//добавляем в счетчик битов 1
          }else {
            if (count<64){ //проделываем тоже самое для второй переменной
              bitWrite(us[1] ,(31-bit2), ((now - prevUs)>800));
              bit2++;
            }
          }
       }
      prevUs = now;               // запомнили время
      count++;
    }
}
